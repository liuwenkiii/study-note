# 周五（07.10）

## ES6 学习

### async

`async` 实际上是 `Generator` 的语法糖。

```javascript
async function f() {
    return 0
}

f().then(v => console.log(v))   // async 函数返回的是 Promise 对象
```

### await

使用 await 等待一个 Promise 对象状态改变，返回该对象的结果。

### Class

`class` 可以看作一个语法糖，它相对于 ES5 的构造函数写法更加清晰。

`constructor` 方法是类的默认构造方法。

使用 `get` 和 `set` 关键字对某个属性设置存值函数和取值函数，拦截其存取行为：

```javascript
class MyClass {
  constructor() {
    // ...
  }
  get prop() {
    return 'getter';
  }
  set prop(value) {
    console.log('setter: '+ value);
  }
}
```

### Class 的继承

与其它语言相同，ES6 使用 `extends` 关键字进行继承。

`super` 可作为对象，代表父类，也可作为函数调用，代表父类的构造函数。子类必须在 `constructor` 中调用 `spuer()` 方法。

### Module 的语法

模块功能主要由两个命令构成：`export` 和 `import`。`export` 命令用于规定模块的对外接口，`import` 命令用于输入其他模块提供的功能。

```javascript
// test.js
export var name = 'name'

// main.js
import { name } from './test.js'
console.log(name) // "name"

// 整体加载
import * as test from './test.js'
console.log(test.name) // "name"

// 动态加载
import('./test.js').then(name => console.log(name))
```

### Module 的加载

传统浏览器加载：

```javascript
<!-- 页面内嵌的脚本 -->
<script type="application/javascript">
  // module code
</script>

<!-- 外部脚本 -->
<script type="application/javascript" src="path/to/myModule.js">
</script>

<!-- 异步加载 -->
<script src="path/to/myModule.js" defer></script>
<script src="path/to/myModule.js" async></script>
```
`defer` 会等待页面渲染完成再加载，`async` 在脚本下载完后加载，会打断页面渲染。

ES6 模块在浏览器中的加载，默认就是异步的，等同于设置了 `defer`：

```javascript
<!-- 需要指定 type="module" -->
<script type="module" src="./foo.js"></script>

<!-- 页面内嵌的脚本 -->
<script type="module">
  import utils from "./utils.js";

  // other code
</script>
```

### ES6 模块与 CommonJS 模块的差异

- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

### Node.js 加载模块

Node.js 中使用 ES6 模块格式需要在 `package.json` 中设置 `"type": "module"`,或者将 ES6 模块文件改为 `.mjs` 后缀名。